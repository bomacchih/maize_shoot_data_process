## Choose assay/slot for SCINA (v1.2.0 works well with RNA/data)
DefaultAssay(seurat_obj) <- "RNA"
expr <- as.matrix(GetAssayData(seurat_obj, assay = "RNA", slot = "data"))  # genes x cells

# Basic sanity
expr[!is.finite(expr)] <- 0
stopifnot(!any(is.na(expr)))
stopifnot(!is.null(rownames(expr)))

# Build: cell_type -> vector of markers
marker_list <- split(marker_df$gene_id, marker_df$cell_type)

# Keep only markers present in object; drop NAs/empties/dups
marker_list <- lapply(marker_list, function(v){
  v <- unique(v[!is.na(v) & nzchar(v)])
  intersect(v, rownames(expr))
})

# (Optional) remove genes shared by >1 type if you plan to rm_overlap=TRUE
dup_tab  <- table(unlist(marker_list))
shared   <- names(dup_tab[dup_tab > 1])
marker_list_disjoint <- lapply(marker_list, setdiff, y = shared)

# Keep types with >= 2 markers (SCINA tends to fail with <2)
marker_list2 <- marker_list_disjoint
marker_list2 <- marker_list2[sapply(marker_list2, length) >= 2]

# Final check
print(sapply(marker_list2, length))
stopifnot(length(marker_list2) > 0)

library(SCINA)
set.seed(1)  # v1.2.0 has no seed arg; set globally

scina_res <- SCINA(
  expr = expr,             # OK to pass positionally or named; older builds ignore the name
  signatures = marker_list2,
  max_iter = 100,
  convergence_n = 10,
  convergence_rate = 0.999,
  sensitivity_cutoff = 1,
  rm_overlap = TRUE,        # set FALSE if you did not remove shared markers above
  allow_unknown = TRUE
)

# expr must be the exact matrix you passed to SCINA (genes x cells)
# Make sure its columns match your Seurat object
stopifnot(all(colnames(expr) %in% colnames(seurat_obj)))

# 1) Name the SCINA labels with the expr column names
labels_scina <- scina_res$cell_labels
if (is.null(names(labels_scina))) {
  names(labels_scina) <- colnames(expr)
}

# 2) Map to Seurat's cell order and add to meta.data
seurat_obj$celltype_scina <- labels_scina[colnames(seurat_obj)]

# 3) (Optional) probabilities — ensure orientation, then attach
prob_scina <- scina_res$probabilities
# Some builds return types x cells; others cells x types. Fix if needed:
if (ncol(prob_scina) == ncol(expr)) {
  # assume rows = types, cols = cells  → transpose to cells x types
  prob_scina <- t(prob_scina)
}
# Now rows should be cells
rownames(prob_scina) <- colnames(expr)
prob_scina <- prob_scina[colnames(seurat_obj), , drop = FALSE]
colnames(prob_scina) <- paste0("SCINA_", colnames(prob_scina))
seurat_obj <- AddMetaData(seurat_obj, as.data.frame(prob_scina))

# 4) Quick sanity checks
table(seurat_obj$celltype_scina)
stopifnot(!any(is.na(seurat_obj$celltype_scina[colnames(expr)])))  # should be all assigned


# Get all unique cell types
cell_types <- unique(seurat_obj$predicted_cell_type)

# Make individual plots
plots <- lapply(cell_types, function(ct) {
  DimPlot(
    seurat_obj,
    group.by = "predicted_cell_type",
    cells.highlight = WhichCells(seurat_obj, ident = ct),
    cols.highlight = "red",
    cols = "grey80",
    sizes.highlight = 1.2,
    pt.size = 0.5
  ) +
    ggtitle(ct) +
    theme(legend.position = "none")
})

# no library(patchwork) needed

png("sc_merged_filter_SCT_inte_celltype_scina.png", width=4000, height=2000, res=300)

combined <- patchwork::wrap_plots(plots, ncol = 4) +
  patchwork::plot_annotation(title = "UMAP Highlight by Cell Type")
combined

dev.off()

